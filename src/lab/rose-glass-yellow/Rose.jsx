/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
*/

import { useGLTF } from '@react-three/drei'
import { useComputeEnvMap } from './useComputeEnvMap'
import { useFrame } from '@react-three/fiber'
import { useMemo, useRef } from 'react'
import {
  BoxGeometry,
  BufferAttribute,
  BufferGeometry,
  FrontSide,
  Mesh,
  MeshBasicMaterial,
  Points,
  ShaderMaterial,
  Vector3,
} from 'three'
import { MeshSurfaceSampler } from 'three/examples/jsm/math/MeshSurfaceSampler'

export function Rose(props) {
  const { nodes, materials } = useGLTF('/rose/rose2.glb?a=2')

  let { envMap: envMapGlass } = useComputeEnvMap(
    /* glsl */ `

  const mat2 m = mat2( 0.80,  0.60, -0.60,  0.80 );

  float noise( in vec2 p ) {
    return sin(p.x)*sin(p.y);
  }

  float fbm4( vec2 p ) {
      float f = 0.0;
      f += 0.5000 * noise( p ); p = m * p * 2.02;
      f += 0.2500 * noise( p ); p = m * p * 2.03;
      f += 0.1250 * noise( p ); p = m * p * 2.01;
      f += 0.0625 * noise( p );
      return f / 0.9375;
  }

  float fbm6( vec2 p ) {
      float f = 0.0;
      f += 0.500000*(0.5 + 0.5 * noise( p )); p = m*p*2.02;
      f += 0.250000*(0.5 + 0.5 * noise( p )); p = m*p*2.03;
      f += 0.125000*(0.5 + 0.5 * noise( p )); p = m*p*2.01;
      f += 0.062500*(0.5 + 0.5 * noise( p )); p = m*p*2.04;
      f += 0.031250*(0.5 + 0.5 * noise( p )); p = m*p*2.01;
      f += 0.015625*(0.5 + 0.5 * noise( p ));
      return f/0.96875;
  }

  float pattern (vec2 p, float time) {
    float vout = fbm4( p + time + fbm6(  p + fbm4( p + time )) );
    return abs(vout);
  }

  uniform sampler2D hdrTexture;
  varying vec3 vWorldDirection;
  varying vec3 vPos;
  #define RECIPROCAL_PI 0.31830988618
  #define RECIPROCAL_PI2 0.15915494

  uniform float time;
  uniform float rotY;

  mat3 rotateY(float rad) {
      float c = cos(rad);
      float s = sin(rad);
      return mat3(
          c, 0.0, -s,
          0.0, 1.0, 0.0,
          s, 0.0, c
      );
  }

  vec4 mainImage ()  {
    vec3 direction = normalize( vWorldDirection * rotateY(time * 2.0 * 1.0 / 60.0));
    vec2 uv;
    uv.y = asin( clamp( direction.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;
    uv.x = atan( direction.z, direction.x ) * RECIPROCAL_PI2 + 0.5;

    // vec4 hdrTextureC4 = texture2D(hdrTexture, uv);

    vec4 outColor;
    outColor.a = 1.0;

    float pLayout1 = pow(pattern(time * 0.5 + uv.xy * 8.0, time * 0.5), 2.0);

    outColor.rgb = vec3(
      pLayout1 * 1.0,
      pLayout1 * 1.0,
      pLayout1 * 1.0
    );

    outColor.r = (1.0 * outColor.r);
    outColor.g = (1.0 * outColor.g);
    outColor.b = (1.0 * outColor.b);

    outColor.rgb += vec3(0.5, 0.5, 0.0);

    return outColor;
  }

  `,
    {},
    64,
    true,
  )

  //
  return (
    <group {...props} dispose={null}>
      {nodes.petals021.geometry && <Particles nodes={nodes}></Particles>}
      <mesh
        name='Stem'
        castShadow
        receiveShadow
        frustumCulled={false}
        geometry={nodes.Stem.geometry}
        material={materials.green}
        position={[0.01582, 0.18058, -0.08771]}
        rotation={[1.1232, 0, -Math.PI / 2]}
        scale={0.00136}
        userData={{ name: 'Stem' }}
      >
        <meshPhysicalMaterial
          metalness={1.0}
          envMapIntensity={1}
          envMap={envMapGlass}
          transmission={1}
          thickness={1}
          roughness={0.0}
          color={'#088'}
        />
      </mesh>
      <mesh
        name='petals021'
        castShadow
        receiveShadow
        frustumCulled={false}
        geometry={nodes.petals021.geometry}
        position={[0.03869, 0.32278, -0.11959]}
        rotation={[1.92032, 0, -Math.PI / 2]}
        scale={0.00136}
        userData={{ name: 'petals.021' }}
      >
        <meshPhysicalMaterial
          metalness={0.5}
          envMapIntensity={1}
          envMap={envMapGlass}
          //
          roughness={0.1}
          color={'#330'}
        />
      </mesh>
      <mesh
        name='petals001'
        castShadow
        receiveShadow
        frustumCulled={false}
        geometry={nodes.petals001.geometry}
        position={[0.03727, 0.30462, -0.06339]}
        rotation={[1.92032, 0, -Math.PI / 2]}
        scale={0.00136}
        userData={{ name: 'petals.001' }}
      >
        <meshPhysicalMaterial
          metalness={0.5}
          envMapIntensity={1}
          envMap={envMapGlass}
          //
          roughness={0.1}
          color={'#330'}
        />
      </mesh>
      <mesh
        name='petals013'
        castShadow
        receiveShadow
        frustumCulled={false}
        geometry={nodes.petals013.geometry}
        position={[0.07679, 0.34146, -0.12545]}
        rotation={[1.92032, 0, -Math.PI / 2]}
        scale={0.00136}
        userData={{ name: 'petals.013' }}
      >
        <meshPhysicalMaterial
          metalness={0.5}
          envMapIntensity={1}
          envMap={envMapGlass}
          //
          roughness={0.1}
          color={'#330'}
        />
      </mesh>
    </group>
  )
}

function Particles({ nodes }) {
  let { primitiveArray, obj } = useMemo(() => {
    if (!nodes?.petals001?.geometry) {
      return {}
    }
    let o3d = []
    let obj = []
    let pedals = [
      {
        geo: nodes?.petals001?.geometry,
        props: {
          position: [0.03727, 0.30462, -0.06339],
          rotation: [1.92032, 0, -Math.PI / 2],
          scale: 0.00136,
        },
        amount: 512 * 256,
      },
      {
        geo: nodes?.petals013?.geometry,
        props: {
          position: [0.07679, 0.34146, -0.12545],
          rotation: [1.92032, 0, -Math.PI / 2],
          scale: 0.00136,
        },
        amount: 512 * 256,
      },
      {
        geo: nodes?.petals021?.geometry,
        props: {
          position: [0.03869, 0.32278, -0.11959],
          rotation: [1.92032, 0, -Math.PI / 2],
          scale: 0.00136,
        },
        amount: 256 * 256,
      },
    ]
    pedals.forEach(({ geo, props, amount = 512 * 512 }) => {
      let mesh = new Mesh(geo || new BoxGeometry(), new MeshBasicMaterial({ side: FrontSide }))
      let sampler = new MeshSurfaceSampler(mesh)
      sampler.build()

      let pointCount = amount // * 0.025
      let sPosition = new BufferAttribute(new Float32Array(pointCount * 4), 4)
      let sNormal = new BufferAttribute(new Float32Array(pointCount * 4), 4)
      let sRand = new BufferAttribute(new Float32Array(pointCount * 1), 1)
      let pos = new Vector3()
      let norm = new Vector3()
      for (let i = 0; i < pointCount; i++) {
        sampler.sample(pos, norm)
        sPosition.setXYZW(i, pos.x, pos.y, pos.z, 1.0)
        sNormal.setXYZW(i, norm.x, norm.y, norm.z, 1.0)
        sRand.setX(i, Math.random())
      }

      let bGeo = new BufferGeometry()
      bGeo.setAttribute('position', sPosition)
      bGeo.setAttribute('sPosition', sPosition)
      bGeo.setAttribute('sNormal', sNormal)
      bGeo.setAttribute('sRand', sRand)
      let points = new Points(
        bGeo,
        new ShaderMaterial({
          precision: 'highp',
          transparent: true,
          uniforms: {
            //
            time: { value: 0 },
            dist: { value: 0 },
            //
          },
          vertexShader: /* glsl */ `
          attribute vec4 sPosition;
          attribute vec4 sNormal;
          attribute float sRand;
          uniform float dist;
          uniform float time;
          mat3 rotateY(float rad) {
              float c = cos(rad);
              float s = sin(rad);
              return mat3(
                  c, 0.0, -s,
                  0.0, 1.0, 0.0,
                  s, 0.0, c
              );
          }
          mat3 rotateX(float rad) {
              float c = cos(rad);
              float s = sin(rad);
              return mat3(
                  1.0, 0.0, 0.0,
                  0.0, c, s,
                  0.0, -s, c
              );
          }
          
          mat3 rotateZ(float rad) {
              float c = cos(rad);
              float s = sin(rad);
              return mat3(
                  c, s, 0.0,
                  -s, c, 0.0,
                  0.0, 0.0, 1.0
              );
          }

          
            void main (void) {
              gl_PointSize = 1.0 / dist;
              if (gl_PointSize >=1.0) {
                gl_PointSize = 1.0;
              }

              float height = 1.0;
              
              float loop = mod(time * 1.5 + sRand * height, height);

              vec3 diff = vec3(
                sNormal.r * loop,
                sNormal.g * loop,
                sNormal.b * loop
              );

              float loop2 = mod(time * 1.0 / 60.0 + sRand * 1.0, 1.0);
              diff += sPosition.rgb * rotateZ(loop2 * 3.141592 * 2.0) / 20.0;

              gl_Position = projectionMatrix * modelViewMatrix * vec4(sPosition.rgb + diff, 1.0);
            }
          `,
          fragmentShader: /* glsl */ `
            uniform float dist;
            void main (void) {
              float maxAlpha = 0.7;
              float alpha = 0.7;
              alpha = alpha / pow(dist, 1.5);
              if (alpha >= maxAlpha) {
                alpha = maxAlpha;
              }
              gl_FragColor = vec4(0.35, 0.35, 0.0, alpha);
            }
          `,
        }),
      )

      o3d.push(
        <group key={points.uuid} {...props}>
          <primitive object={points}></primitive>
        </group>,
      )

      obj.push(points)
    })
    return { primitiveArray: o3d, obj: obj }
  }, [nodes?.petals001?.geometry, nodes?.petals013?.geometry, nodes?.petals021?.geometry])
  useFrame(({ controls }) => {
    if (controls && obj?.length > 0) {
      obj.forEach((o) => {
        o.material.uniforms.dist.value = controls.object.position.distanceTo(controls.target) || 0
        o.material.uniforms.time.value = performance.now() / 1000
      })
    }
  })

  return <>{primitiveArray || []}</>
}
