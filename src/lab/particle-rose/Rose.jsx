/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
*/

import { useGLTF } from '@react-three/drei'
import { useComputeEnvMap } from './useComputeEnvMap'
import { useFrame } from '@react-three/fiber'
import { useMemo, useRef } from 'react'
import {
  AdditiveBlending,
  BoxGeometry,
  BufferAttribute,
  BufferGeometry,
  FrontSide,
  Mesh,
  MeshBasicMaterial,
  Points,
  ShaderMaterial,
  SubtractiveBlending,
  Vector3,
} from 'three'
import { MeshSurfaceSampler } from 'three/examples/jsm/math/MeshSurfaceSampler'

export function Rose(props) {
  const { nodes, materials } = useGLTF('/rose/rose2.glb?a=2')

  let { envMap: envMapGlass } = useComputeEnvMap(
    /* glsl */ `

  const mat2 m = mat2( 0.80,  0.60, -0.60,  0.80 );

  float noise( in vec2 p ) {
    return sin(p.x)*sin(p.y);
  }

  float fbm4( vec2 p ) {
      float f = 0.0;
      f += 0.5000 * noise( p ); p = m * p * 2.02;
      f += 0.2500 * noise( p ); p = m * p * 2.03;
      f += 0.1250 * noise( p ); p = m * p * 2.01;
      f += 0.0625 * noise( p );
      return f / 0.9375;
  }

  float fbm6( vec2 p ) {
      float f = 0.0;
      f += 0.500000*(0.5 + 0.5 * noise( p )); p = m*p*2.02;
      f += 0.250000*(0.5 + 0.5 * noise( p )); p = m*p*2.03;
      f += 0.125000*(0.5 + 0.5 * noise( p )); p = m*p*2.01;
      f += 0.062500*(0.5 + 0.5 * noise( p )); p = m*p*2.04;
      f += 0.031250*(0.5 + 0.5 * noise( p )); p = m*p*2.01;
      f += 0.015625*(0.5 + 0.5 * noise( p ));
      return f/0.96875;
  }

  float pattern (vec2 p, float time) {
    float vout = fbm4( p + time + fbm6(  p + fbm4( p + time )) );
    return abs(vout);
  }

  uniform sampler2D hdrTexture;
  varying vec3 vWorldDirection;
  varying vec3 vPos;
  #define RECIPROCAL_PI 0.31830988618
  #define RECIPROCAL_PI2 0.15915494

  uniform float time;
  uniform float rotY;

  mat3 rotateY(float rad) {
      float c = cos(rad);
      float s = sin(rad);
      return mat3(
          c, 0.0, -s,
          0.0, 1.0, 0.0,
          s, 0.0, c
      );
  }

  vec4 mainImage ()  {
    vec3 direction = normalize( vWorldDirection * rotateY(time * 2.0 * 1.0 / 60.0));
    vec2 uv;
    uv.y = asin( clamp( direction.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;
    uv.x = atan( direction.z, direction.x ) * RECIPROCAL_PI2 + 0.5;

    // vec4 hdrTextureC4 = texture2D(hdrTexture, uv);

    vec4 outColor;
    outColor.a = 1.0;

    float pLayout1 = pow(pattern(time * 0.5 + uv.xy * 8.0, time * 0.5), 2.0);

    outColor.rgb = vec3(
      pLayout1 * 1.0,
      pLayout1 * 1.0,
      pLayout1 * 1.0
    );

    outColor.r = (2.0 * outColor.r);
    outColor.g = (0.5 * outColor.g);
    outColor.b = (0.5 * outColor.b);

    return outColor;
  }

  `,
    {},
    64,
    true,
  )

  //
  return (
    <group {...props} dispose={null}>
      {nodes.petals021.geometry && <Particles nodes={nodes}></Particles>}
      <mesh
        name='Stem'
        castShadow
        receiveShadow
        frustumCulled={false}
        geometry={nodes.Stem.geometry}
        material={materials.green}
        position={[0.01582, 0.18058, -0.08771]}
        rotation={[1.1232, 0, -Math.PI / 2]}
        scale={0.00136}
        userData={{ name: 'Stem' }}
      >
        <meshPhysicalMaterial
          metalness={1.0}
          envMapIntensity={1}
          envMap={envMapGlass}
          transmission={1}
          thickness={1}
          roughness={0.0}
          color={'#088'}
        />
      </mesh>
      <mesh
        name='petals021'
        castShadow
        receiveShadow
        frustumCulled={false}
        geometry={nodes.petals021.geometry}
        position={[0.03869, 0.32278, -0.11959]}
        rotation={[1.92032, 0, -Math.PI / 2]}
        scale={0.00136}
        userData={{ name: 'petals.021' }}
      >
        <meshPhysicalMaterial
          metalness={0.5}
          envMapIntensity={1}
          envMap={envMapGlass}
          //
          roughness={0.1}
          color={'#f00'}
        />
      </mesh>
      <mesh
        name='petals001'
        castShadow
        receiveShadow
        frustumCulled={false}
        geometry={nodes.petals001.geometry}
        position={[0.03727, 0.30462, -0.06339]}
        rotation={[1.92032, 0, -Math.PI / 2]}
        scale={0.00136}
        userData={{ name: 'petals.001' }}
      >
        <meshPhysicalMaterial
          metalness={0.5}
          envMapIntensity={1}
          envMap={envMapGlass}
          //
          roughness={0.1}
          color={'#f00'}
        />
      </mesh>
      <mesh
        name='petals013'
        castShadow
        receiveShadow
        frustumCulled={false}
        geometry={nodes.petals013.geometry}
        position={[0.07679, 0.34146, -0.12545]}
        rotation={[1.92032, 0, -Math.PI / 2]}
        scale={0.00136}
        userData={{ name: 'petals.013' }}
      >
        <meshPhysicalMaterial
          metalness={0.5}
          envMapIntensity={1}
          envMap={envMapGlass}
          //
          roughness={0.1}
          color={'#f00'}
        />
      </mesh>
    </group>
  )
}

function Particles({ nodes }) {
  let { primitiveArray, obj } = useMemo(() => {
    if (!nodes?.petals001?.geometry) {
      return {}
    }
    let o3d = []
    let obj = []
    let pedals = [
      {
        geo: nodes?.petals001?.geometry,
        props: {
          position: [0.03727, 0.30462, -0.06339],
          rotation: [1.92032, 0, -Math.PI / 2],
          scale: 0.00136,
        },
        amount: 512,
      },
      {
        geo: nodes?.petals013?.geometry,
        props: {
          position: [0.07679, 0.34146, -0.12545],
          rotation: [1.92032, 0, -Math.PI / 2],
          scale: 0.00136,
        },
        amount: 512,
      },
      {
        geo: nodes?.petals021?.geometry,
        props: {
          position: [0.03869, 0.32278, -0.11959],
          rotation: [1.92032, 0, -Math.PI / 2],
          scale: 0.00136,
        },
        amount: 512,
      },
    ]
    pedals.forEach(({ geo, props, amount = 512 * 512 }) => {
      // props = {}
      // geo
      // amount
      let mesh = new Mesh(geo || new BoxGeometry(), new MeshBasicMaterial({ side: FrontSide }))
      let sampler = new MeshSurfaceSampler(mesh)
      sampler.build()

      let pointCount = amount // * 0.025
      let sPosition = new BufferAttribute(new Float32Array(pointCount * 4), 4)
      let sNormal = new BufferAttribute(new Float32Array(pointCount * 4), 4)
      let sRand = new BufferAttribute(new Float32Array(pointCount * 1), 1)
      let pos = new Vector3()
      let norm = new Vector3()
      for (let i = 0; i < pointCount; i++) {
        sampler.sample(pos, norm)
        sPosition.setXYZW(i, pos.x, pos.y, pos.z, 1.0)
        sNormal.setXYZW(i, norm.x, norm.y, norm.z, 1.0)
        sRand.setX(i, Math.random())
      }

      let bGeo = new BufferGeometry()
      bGeo.setAttribute('position', sPosition)
      bGeo.setAttribute('sPosition', sPosition)
      bGeo.setAttribute('sNormal', sNormal)
      bGeo.setAttribute('sRand', sRand)
      let points = new Points(
        bGeo,
        new ShaderMaterial({
          transparent: true,
          blending: AdditiveBlending,
          depthWrite: false,
          depthTest: true,
          uniforms: {
            //
            iTime: { value: 0 },
            time: { value: 0 },
            dist: { value: 0 },
            //
          },
          vertexShader: /* glsl */ `
          attribute vec4 sPosition;
          attribute vec4 sNormal;
          attribute float sRand;
          varying float vRand; 
          uniform float dist;
          uniform float time;

          mat3 rotateY(float rad) {
              float c = cos(rad);
              float s = sin(rad);
              return mat3(
                  c, 0.0, -s,
                  0.0, 1.0, 0.0,
                  s, 0.0, c
              );
          }

          mat3 rotateX(float rad) {
              float c = cos(rad);
              float s = sin(rad);
              return mat3(
                  1.0, 0.0, 0.0,
                  0.0, c, s,
                  0.0, -s, c
              );
          }
          
          mat3 rotateZ(float rad) {
              float c = cos(rad);
              float s = sin(rad);
              return mat3(
                  c, s, 0.0,
                  -s, c, 0.0,
                  0.0, 0.0, 1.0
              );
          }
        
          void main (void) {
            vRand = sRand;
            
            gl_PointSize =  250.0 / dist;
            if (gl_PointSize >= 250.0) {
              gl_PointSize =  250.0;
            }

            float height = 5.0;
            
            float loop = mod(time * 1.5 + sRand * height, height);

            vec3 diff = vec3(
              sNormal.r * loop,
              sNormal.g * 3.0 * loop,
              sNormal.b * loop
            );

            float loop2 = mod(time + sRand * 1.0, 1.0);

            vec4 rNormal = modelViewMatrix * sNormal;
            vec4 rPosition = modelViewMatrix * sPosition;

            // diff += normalize(rPosition.rgb) * rotateX(time * 3.141592) * 1.0;
            // diff += normalize(rPosition.rgb) * rotateY(time * 0.5 * 3.141592) * 1.0;
            // diff += normalize(rPosition.rgb) * rotateZ(time * 3.141592) * 1.0;

            // diff += normalize(sPosition.rgb) * rotateY(loop2 * 3.141592) * 1.0;
            // diff += normalize(sPosition.rgb) * rotateZ(loop2 * 3.141592) * 1.0;

            gl_Position = projectionMatrix * modelViewMatrix * vec4(sPosition.rgb, 1.0);

            gl_Position.y += 0.05;
          }
          `,
          fragmentShader: /* glsl */ `
            uniform float time;
            uniform float iTime;
            varying float vRand;
            //////////////////////
            // Fire Flame shader

            // procedural noise from IQ
            vec2 hash( vec2 p )
            {
              p = vec2( dot(p,vec2(127.1,311.7)),
                  dot(p,vec2(269.5,183.3)) );
              return -1.0 + 2.0*fract(sin(p)*43758.5453123);
            }

            float noise( in vec2 p )
            {
              const float K1 = 0.366025404; // (sqrt(3)-1)/2;
              const float K2 = 0.211324865; // (3-sqrt(3))/6;
              
              vec2 i = floor( p + (p.x+p.y)*K1 );
              
              vec2 a = p - i + (i.x+i.y)*K2;
              vec2 o = (a.x>a.y) ? vec2(1.0,0.0) : vec2(0.0,1.0);
              vec2 b = a - o + K2;
              vec2 c = a - 1.0 + 2.0*K2;
              
              vec3 h = max( 0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );
              
              vec3 n = h*h*h*h*vec3( dot(a,hash(i+0.0)), dot(b,hash(i+o)), dot(c,hash(i+1.0)));
              
              return dot( n, vec3(70.0) );
            }

            float fbm(vec2 uv)
            {
              float f;
              mat2 m = mat2( 1.6,  1.2, -1.2,  1.6 );
              f  = 0.5000*noise( uv ); uv = m*uv;
              f += 0.2500*noise( uv ); uv = m*uv;
              f += 0.1250*noise( uv ); uv = m*uv;
              f += 0.0625*noise( uv ); uv = m*uv;
              f = 0.5 + 0.5*f;
              return f;
            }

            // no defines, standard redish flames
            //#define BLUE_FLAME
            //#define GREEN_FLAME

            vec4 fireImage( )
            {
              vec2 uv = vec2(gl_PointCoord.x, 1.0 - gl_PointCoord.y);
              vec2 q = uv;
              //q.x *= 2.;
                q.y *= 2.;
              
                float strength = floor(q.x+1.);
              float T3 = max(3.,1.25*strength)*(iTime + vRand);
              q.x = mod(q.x,1.)-0.5;
              q.y -= 0.25;
                
                q.x = q.x * 1.5;
              
              float n = fbm(strength*q - vec2(0,T3));
              float c = 1. - 16. * pow( max( 0., length(q*vec2(1.8+q.y*1.5,.75) ) - n * max( 0., q.y+.25 ) ),1.2 );
              float c1 = n * c * (1.5-pow(1.25*uv.y,4.));
                
            //	float c1 = n * c * (1.5-pow(2.50*uv.y,4.));
              c1 = clamp(c1,0.,1.);

              vec3 col = vec3(1.5*c1, 1.5*c1*c1*c1, c1*c1*c1*c1*c1*c1);
              
              
              float a = c * (1.-pow(uv.y,3.)) * 1.0;
              vec4 fireColor = vec4( mix(vec3(0.),col,a), 1.0);

              float avgcoor = (fireColor.r + fireColor.g + fireColor.b) / 3.0;

              return vec4(fireColor.rgb, avgcoor * 0.1);
            }

            uniform float dist;
            void main (void) {
              // float maxAlpha = 1.0;
              // float alpha = 1.0;
              // alpha = alpha / pow(dist, 1.5);
              // if (alpha >= maxAlpha) {
              //   alpha = maxAlpha;
              // }

              vec4 fire = fireImage();
              
              gl_FragColor = vec4(fire.rgba);
            }
          `,
        }),
      )

      o3d.push(
        <group key={points.uuid} {...props}>
          <primitive object={points}></primitive>
        </group>,
      )

      obj.push(points)
    })
    return { primitiveArray: o3d, obj: obj }
  }, [nodes?.petals001?.geometry, nodes?.petals013?.geometry, nodes?.petals021?.geometry])

  useFrame(({ controls }, dt) => {
    if (controls && obj?.length > 0) {
      obj.forEach((o) => {
        o.material.uniforms.dist.value = controls.object.position.distanceTo(controls.target) || 0
        o.material.uniforms.time.value = performance.now() / 1000
        o.material.uniforms.iTime.value = performance.now() / 1000
      })
    }
  })

  return <>{primitiveArray || []}</>
}
